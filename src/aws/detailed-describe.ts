import { $ } from "bun";
import { readdir, stat } from "node:fs/promises";
import { join } from "node:path";
import { getTOTPSecret, generateTOTPToken } from "../lib/totp";
import { getVersion } from "../lib/version";
import { getAccountId } from "./aws-cli";

async function obtainAWSCredentials(
  accountName: string,
  mfaToken: string,
  log: (msg: string) => void,
): Promise<void> {
  log(`\nObtaining credentials for account: ${accountName}`);

  try {
    const result =
      await $`letme obtain ${accountName} --inline-mfa ${mfaToken}`.quiet();

    if (result.exitCode === 0) {
      // Set the AWS profile to use the obtained credentials
      process.env.AWS_PROFILE = accountName;
      log("Credentials obtained successfully");
      return;
    } else {
      console.error(
        `letme failed with exit code ${result.exitCode}: ${result.stderr}`,
      );
      process.exit(1);
    }
  } catch (error) {
    console.error(`letme failed: ${error}`);
    process.exit(1);
  }
}

/**
 * Generate metadata excerpt for markdown files
 */
async function generateMetadataExcerpt(
  accountName: string,
  region: string,
  serviceName: string,
): Promise<string> {
  const version = await getVersion();
  const now = new Date();
  const formattedDate =
    now.toISOString().replace("T", " ").substring(0, 19) + " UTC";

  // Try to get the AWS account ID
  let accountId = "N/A";
  try {
    accountId = await getAccountId();
  } catch (error) {
    // If we can't get the account ID, leave it as N/A
  }

  // Determine if using letme (account name is not a 12-digit number and not "local")
  const isLetmeAccount =
    accountName !== "local" && !/^\d{12}$/.test(accountName);

  let excerpt = `\n`;
  excerpt += `- **Generated by AWS Inventory Generator v${version}**\n`;
  excerpt += `- **Account ID:** ${accountId}\n`;
  if (isLetmeAccount) {
    excerpt += `- **Account Name (letme):** ${accountName}\n`;
  }
  excerpt += `- **Region:** ${region}\n`;
  excerpt += `- **Service:** ${serviceName}\n`;
  excerpt += `- **Generated on:** ${formattedDate}\n`;
  excerpt += `\n`;

  return excerpt;
}

/**
 * Insert metadata after the first H1 title in markdown content
 */
function insertMetadataAfterH1(
  markdownContent: string,
  metadata: string,
): string {
  // Find the first H1 line
  const lines = markdownContent.split("\n");
  let h1Index = -1;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line && line.startsWith("# ")) {
      h1Index = i;
      break;
    }
  }

  if (h1Index === -1) {
    // No H1 found, prepend metadata to content
    return metadata + markdownContent;
  }

  // Insert metadata after the H1
  lines.splice(h1Index + 1, 0, metadata);
  return lines.join("\n");
}

/**
 * Extract the actual resource data from AWS CLI response
 * AWS CLI returns different structures:
 * - Single object: { "User": {...} }, { "Role": {...} }
 * - Array: { "Vpcs": [{...}] }, { "Subnets": [{...}] }
 * - Nested: { "Reservations": [{ "Instances": [{...}] }] } (EC2)
 */
function extractResourceFromResponse(response: any): any {
  // Special handling for EC2 - has nested structure: Reservations -> Instances
  if (
    response.Reservations &&
    Array.isArray(response.Reservations) &&
    response.Reservations.length > 0
  ) {
    const reservation = response.Reservations[0];
    if (
      reservation.Instances &&
      Array.isArray(reservation.Instances) &&
      reservation.Instances.length > 0
    ) {
      return reservation.Instances[0];
    }
  }

  // Special handling for CloudWatch - MetricAlarms is an array
  if (
    response.MetricAlarms &&
    Array.isArray(response.MetricAlarms) &&
    response.MetricAlarms.length > 0
  ) {
    return response.MetricAlarms[0];
  }

  // List of known wrapper keys (singular and plural forms)
  const wrapperKeys = [
    "User",
    "Users",
    "Role",
    "Roles",
    "Vpc",
    "Vpcs",
    "Subnet",
    "Subnets",
    "SecurityGroup",
    "SecurityGroups",
    "Instance",
    "Instances",
    "DBInstance",
    "DBInstances",
    "Function",
    "Functions",
    "Table",
    "Tables",
    "Cluster",
    "Clusters",
    "Distribution",
    "Distributions",
    "HostedZone",
    "HostedZones",
    "Key",
    "Keys",
    "Alarm",
    "Alarms",
    "Secret",
    "Secrets",
    "Repository",
    "Repositories",
    "InternetGateway",
    "InternetGateways",
    "NatGateway",
    "NatGateways",
    "Address",
    "Addresses",
    "VpnGateway",
    "VpnGateways",
    "VpnConnection",
    "VpnConnections",
    "TransitGateway",
    "TransitGateways",
    "VpcEndpoint",
    "VpcEndpoints",
    "VpcPeeringConnection",
    "VpcPeeringConnections",
    "NetworkAcl",
    "NetworkAcls",
    "RouteTable",
    "RouteTables",
    "NetworkInterface",
    "NetworkInterfaces",
    "LoadBalancer",
    "LoadBalancers",
  ];

  for (const key of wrapperKeys) {
    if (response[key]) {
      // If it's an array, extract the first element
      if (Array.isArray(response[key]) && response[key].length > 0) {
        return response[key][0];
      }
      // Otherwise return the object directly
      return response[key];
    }
  }

  // If no wrapper found, return the whole response
  return response;
}

/**
 * Create a consolidated response structure that the markdown converter expects
 * Converts from individual resources to array format
 */
function createConsolidatedResponse(
  serviceName: string,
  resources: any[],
): any {
  // Map service names to the array keys expected by the markdown converter
  const serviceToArrayKey: Record<string, string> = {
    EC2: "Reservations",
    RDS: "DBInstances",
    S3: "Buckets",
    VPC: "Vpcs",
    Subnet: "Subnets",
    SecurityGroup: "SecurityGroups",
    LoadBalancer: "LoadBalancers",
    Lambda: "Functions",
    DynamoDB: "Tables",
    ECS: "clusters",
    EKS: "clusters",
    CloudFront: "DistributionList",
    Route53: "HostedZones",
    IAMUser: "Users",
    IAMRole: "Roles",
    Redshift: "Clusters",
    Glue: "JobList",
    OpenSearch: "DomainStatusList",
    KMS: "KeyList",
    CloudWatch: "MetricAlarms",
    SecretsManager: "SecretList",
    ECR: "repositories",
    InternetGateway: "InternetGateways",
    NatGateway: "NatGateways",
    ElasticIP: "Addresses",
    VpnGateway: "VpnGateways",
    VpnConnection: "VpnConnections",
    TransitGateway: "TransitGateways",
    VpcEndpoint: "VpcEndpoints",
    VpcPeering: "VpcPeeringConnections",
    NetworkAcl: "NetworkAcls",
    RouteTable: "RouteTables",
    NetworkInterface: "NetworkInterfaces",
  };

  const arrayKey = serviceToArrayKey[serviceName] || serviceName;

  // Special handling for EC2 (needs Reservations wrapper)
  if (serviceName === "EC2") {
    return {
      Reservations: resources.map((instance) => ({
        Instances: [instance],
      })),
    };
  }

  // Special handling for CloudFront
  if (serviceName === "CloudFront") {
    return {
      DistributionList: {
        Items: resources,
      },
    };
  }

  // Special handling for EKS
  if (serviceName === "EKS") {
    return {
      clusters: {
        items: resources,
      },
    };
  }

  // Default: return array under the appropriate key
  return {
    [arrayKey]: resources,
  };
}

// Service configuration for detailed descriptions
const serviceConfigs = [
  {
    name: "EC2",
    csvPattern: /^EC2-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0, // First column
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-instances --instance-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "RDS",
    csvPattern: /^RDS-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws rds describe-db-instances --db-instance-identifier ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "VPC",
    csvPattern: /^VPC-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-vpcs --vpc-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "Subnet",
    csvPattern: /^Subnet-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-subnets --subnet-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "SecurityGroup",
    csvPattern: /^SecurityGroup-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-security-groups --group-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "LoadBalancer",
    csvPattern: /^LoadBalancer-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0, // Name
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws elbv2 describe-load-balancers --names ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "Lambda",
    csvPattern: /^Lambda-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0, // Name
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws lambda get-function --function-name ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "DynamoDB",
    csvPattern: /^DynamoDB-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0, // Name
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws dynamodb describe-table --table-name ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "ECS",
    csvPattern: /^ECS-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0, // Name
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ecs describe-clusters --clusters ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "EKS",
    csvPattern: /^EKS-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0, // Name
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws eks describe-cluster --name ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "CloudFront",
    csvPattern: /^CloudFront-global-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) => $`aws cloudfront get-distribution --id ${id} --output ${outputFormat}`,
    regionRequired: false,
  },
  {
    name: "Route53",
    csvPattern: /^Route53-global-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) => $`aws route53 get-hosted-zone --id ${id} --output ${outputFormat}`,
    regionRequired: false,
  },
  {
    name: "IAMUser",
    csvPattern: /^IAMUser-global-(\d{8})-(.+)\.csv$/,
    idField: 0, // UserName
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) => $`aws iam get-user --user-name ${id} --output ${outputFormat}`,
    regionRequired: false,
  },
  {
    name: "IAMRole",
    csvPattern: /^IAMRole-global-(\d{8})-(.+)\.csv$/,
    idField: 0, // RoleName
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) => $`aws iam get-role --role-name ${id} --output ${outputFormat}`,
    regionRequired: false,
  },
  {
    name: "Redshift",
    csvPattern: /^Redshift-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0, // ClusterIdentifier
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws redshift describe-clusters --cluster-identifier ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "Glue",
    csvPattern: /^Glue-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0, // Name
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws glue get-job --job-name ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "OpenSearch",
    csvPattern: /^OpenSearch-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0, // DomainName
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws opensearch describe-domain --domain-name ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "KMS",
    csvPattern: /^KMS-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0, // KeyID
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws kms describe-key --key-id ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "CloudWatch",
    csvPattern: /^CloudWatch-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0, // AlarmName
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws cloudwatch describe-alarms --alarm-names ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "SecretsManager",
    csvPattern: /^SecretsManager-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0, // Name
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws secretsmanager describe-secret --secret-id ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "ECR",
    csvPattern: /^ECR-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0, // RepositoryName
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ecr describe-repositories --repository-names ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "InternetGateway",
    csvPattern: /^InternetGateway-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-internet-gateways --internet-gateway-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "NatGateway",
    csvPattern: /^NatGateway-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-nat-gateways --nat-gateway-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "ElasticIP",
    csvPattern: /^ElasticIP-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0, // AllocationID
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-addresses --allocation-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "VpnGateway",
    csvPattern: /^VpnGateway-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-vpn-gateways --vpn-gateway-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "VpnConnection",
    csvPattern: /^VpnConnection-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-vpn-connections --vpn-connection-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "TransitGateway",
    csvPattern: /^TransitGateway-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-transit-gateways --transit-gateway-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "VpcEndpoint",
    csvPattern: /^VpcEndpoint-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-vpc-endpoints --vpc-endpoint-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "VpcPeering",
    csvPattern: /^VpcPeering-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-vpc-peering-connections --vpc-peering-connection-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "NetworkAcl",
    csvPattern: /^NetworkAcl-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-network-acls --network-acl-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "RouteTable",
    csvPattern: /^RouteTable-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-route-tables --route-table-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
  {
    name: "NetworkInterface",
    csvPattern: /^NetworkInterface-([^-]+(?:-[^-]+)*)-(\d{8})-(.+)\.csv$/,
    idField: 0,
    describeCommand: (
      id: string,
      region: string,
      account: string,
      outputFormat: string,
    ) =>
      $`aws ec2 describe-network-interfaces --network-interface-ids ${id} --region ${region} --output ${outputFormat}`,
    regionRequired: true,
  },
];

async function processSingleCsvFile(
  csvFilePath: string,
  verbose: boolean,
  outputFormat: string,
  log: (msg: string) => void,
) {
  const fileName = csvFilePath.split("/").pop() || "";

  // Find which service config matches this file
  let matchedConfig = null;
  let region = "unknown";
  let timestamp = "";
  let account = "unknown";

  for (const config of serviceConfigs) {
    const match = fileName.match(config.csvPattern);
    if (match) {
      matchedConfig = config;
      region = config.regionRequired ? match[1]! : "global";
      timestamp = config.regionRequired ? match[2]! : match[1]!;
      account = config.regionRequired ? match[3]! : match[2]!;
      break;
    }
  }

  if (!matchedConfig) {
    throw new Error(
      `Unable to parse filename: ${fileName}. File does not match any known service pattern.`,
    );
  }

  log(`Processing CSV file: ${fileName}`);
  log(`Service: ${matchedConfig.name}, Region: ${region}, Account: ${account}`);

  // Check if this is a local profile account (either "local" or a 12-digit account ID)
  const isLocalProfile = account === "local" || /^\d{12}$/.test(account);

  if (!isLocalProfile) {
    // This is a letme-managed account, authenticate with TOTP
    if (process.env.AWS_PROFILE !== account) {
      const secret = await getTOTPSecret();
      const mfaToken = generateTOTPToken(secret);
      log(`Generated MFA token for ${account}: ${mfaToken}`);
      await obtainAWSCredentials(account, mfaToken, log);
    }
  } else {
    // This is a local profile, use default AWS credentials
    delete process.env.AWS_PROFILE;
  }

  // Determine output directory (same directory as the CSV file)
  const outputDir = csvFilePath.substring(0, csvFilePath.lastIndexOf("/"));

  // Collect all JSON responses for markdown consolidation
  const allResourcesJson: any[] = [];

  // Read the CSV file
  const csvContent = await Bun.file(csvFilePath).text();
  const lines = csvContent.split("\n").slice(1); // Skip header

  for (const line of lines) {
    if (!line.trim()) continue;
    const columns = line.split(",");
    const id = columns[matchedConfig.idField]?.trim();
    if (!id) continue;

    log(`Describing ${matchedConfig.name} ${id}`);
    try {
      if (outputFormat === "markdown") {
        // For markdown, collect JSON responses
        const result = await matchedConfig
          .describeCommand(id, region, account, "json")
          .quiet();
        const jsonData = JSON.parse(result.stdout.toString());

        // Extract the actual resource from the response
        const resourceData = extractResourceFromResponse(jsonData);
        if (resourceData) {
          allResourcesJson.push(resourceData);
        }
      } else {
        // For json/text, write individual files
        // Create directory if it doesn't exist yet
        await $`mkdir -p ${outputDir}/detailed-describes/${matchedConfig.name}`;

        const result = await matchedConfig
          .describeCommand(id, region, account, outputFormat)
          .quiet();
        const content = result.stdout.toString();
        const extension = outputFormat === "json" ? "json" : "txt";

        await Bun.write(
          `${outputDir}/detailed-describes/${matchedConfig.name}/${id}.${extension}`,
          content,
        );
      }
    } catch (error: any) {
      console.error(`Failed to describe ${id}: ${error}`);
      if (error.exitCode) console.error(`Exit code: ${error.exitCode}`);
      if (error.stderr) console.error(`Stderr: ${error.stderr}`);
    }
  }

  // Write consolidated markdown file for this service
  if (outputFormat === "markdown" && allResourcesJson.length > 0) {
    // Create detailed-describes directory if it doesn't exist
    await $`mkdir -p ${outputDir}/detailed-describes`;

    const { convertToMarkdown } = await import(
      "../prettify/markdown-converter"
    );

    // Create a consolidated response structure that the converter expects
    const consolidatedResponse = createConsolidatedResponse(
      matchedConfig.name,
      allResourcesJson,
    );
    const markdownContent = convertToMarkdown(
      JSON.stringify(consolidatedResponse),
      "json",
    );

    // Generate metadata excerpt
    const metadataExcerpt = await generateMetadataExcerpt(
      account,
      region,
      matchedConfig.name,
    );

    // Insert metadata after H1 title
    const finalMarkdown = insertMetadataAfterH1(
      markdownContent,
      metadataExcerpt,
    );

    await Bun.write(
      `${outputDir}/detailed-describes/${matchedConfig.name}.md`,
      finalMarkdown,
    );
    log(
      `Wrote consolidated markdown for ${matchedConfig.name} (${allResourcesJson.length} resources)`,
    );
  }

  log("Detailed descriptions generated.");
}

async function processSingleFolder(
  folder: string,
  verbose: boolean,
  outputFormat: string,
  log: (msg: string) => void,
) {
  // Extract account name from folder path, assuming format inventory-output/account-region-timestamp
  const folderName = folder.split("/").pop() || "";
  // Remove timestamp (last 8 digits) and region to get account name
  // Format: account-region-timestamp or account-timestamp
  const account = folderName.replace(/-\d{8}$/, "").split("-")[0] || "unknown";

  log(
    `Generating detailed descriptions for inventory in ${folder} (account: ${account})`,
  );

  // Check if this is a local profile account (either "local" or a 12-digit account ID)
  const isLocalProfile = account === "local" || /^\d{12}$/.test(account);

  if (!isLocalProfile) {
    // This is a letme-managed account, authenticate with TOTP
    if (process.env.AWS_PROFILE !== account) {
      const secret = await getTOTPSecret();
      const mfaToken = generateTOTPToken(secret);
      log(`Generated MFA token for ${account}: ${mfaToken}`);
      await obtainAWSCredentials(account, mfaToken, log);
    }
  } else {
    // This is a local profile, use default AWS credentials
    delete process.env.AWS_PROFILE;
  }

  // Find all CSV files
  const files = await readdir(folder);

  for (const config of serviceConfigs) {
    const serviceFiles = files.filter((f) => config.csvPattern.test(f));

    if (serviceFiles.length === 0) continue;

    // Collect all JSON responses for markdown consolidation
    const allResourcesJson: any[] = [];

    for (const file of serviceFiles) {
      const match = file.match(config.csvPattern);
      if (!match) {
        console.error(`Invalid filename format: ${file}`);
        continue;
      }
      const region = config.regionRequired ? match[1]! : "global";
      const timestamp = config.regionRequired ? match[2]! : match[1]!;
      const accountFromFile = config.regionRequired ? match[3]! : match[2]!;

      log(`Processing ${file} (region: ${region})`);

      const csvContent = await Bun.file(`${folder}/${file}`).text();
      const lines = csvContent.split("\n").slice(1); // Skip header

      for (const line of lines) {
        if (!line.trim()) continue;
        const columns = line.split(",");
        const id = columns[config.idField]?.trim();
        if (!id) continue;

        log(`Describing ${config.name} ${id}`);
        try {
          if (outputFormat === "markdown") {
            // For markdown, collect JSON responses
            const result = await config
              .describeCommand(id, region, account, "json")
              .quiet();
            const jsonData = JSON.parse(result.stdout.toString());

            // Extract the actual resource from the response
            // AWS CLI returns different structures, extract the first non-metadata value
            const resourceData = extractResourceFromResponse(jsonData);
            if (resourceData) {
              allResourcesJson.push(resourceData);
            }
          } else {
            // For json/text, write individual files
            // Create directory if it doesn't exist yet
            await $`mkdir -p ${folder}/detailed-describes/${config.name}`;

            const result = await config
              .describeCommand(id, region, account, outputFormat)
              .quiet();
            const content = result.stdout.toString();
            const extension = outputFormat === "json" ? "json" : "txt";

            await Bun.write(
              `${folder}/detailed-describes/${config.name}/${id}.${extension}`,
              content,
            );
          }
        } catch (error: any) {
          console.error(`Failed to describe ${id}: ${error}`);
          if (error.exitCode) console.error(`Exit code: ${error.exitCode}`);
          if (error.stderr) console.error(`Stderr: ${error.stderr}`);
        }
      }
    }

    // Write consolidated markdown file for this service
    if (outputFormat === "markdown" && allResourcesJson.length > 0) {
      // Create detailed-describes directory if it doesn't exist
      await $`mkdir -p ${folder}/detailed-describes`;

      const { convertToMarkdown } = await import(
        "../prettify/markdown-converter"
      );

      // Create a consolidated response structure that the converter expects
      const consolidatedResponse = createConsolidatedResponse(
        config.name,
        allResourcesJson,
      );
      const markdownContent = convertToMarkdown(
        JSON.stringify(consolidatedResponse),
        "json",
      );

      // Generate metadata excerpt
      // Extract region from the first file processed
      const firstFile = files.filter((f) => config.csvPattern.test(f))[0];
      const match = firstFile?.match(config.csvPattern);
      const region = config.regionRequired && match ? match[1]! : "global";
      const metadataExcerpt = await generateMetadataExcerpt(
        account,
        region,
        config.name,
      );

      // Insert metadata after H1 title
      const finalMarkdown = insertMetadataAfterH1(
        markdownContent,
        metadataExcerpt,
      );

      await Bun.write(
        `${folder}/detailed-describes/${config.name}.md`,
        finalMarkdown,
      );
      log(
        `Wrote consolidated markdown for ${config.name} (${allResourcesJson.length} resources)`,
      );
    }
  }

  log("Detailed descriptions generated.");
}

export async function generateDetailedDescriptions(
  path: string,
  verbose: boolean,
  outputFormat: string = "markdown",
) {
  const log = verbose ? console.log : () => {};

  // Check if the path exists and determine if it's a file or directory
  try {
    const pathStat = await stat(path);

    // If it's a CSV file, process just that file
    if (pathStat.isFile() && path.endsWith(".csv")) {
      await processSingleCsvFile(path, verbose, outputFormat, log);
      return;
    }

    // If it's not a directory at this point, throw an error
    if (!pathStat.isDirectory()) {
      throw new Error(`${path} is not a directory or CSV file`);
    }
  } catch (error) {
    throw new Error(`Failed to access path ${path}: ${error}`);
  }

  // Read the contents of the directory
  const entries = await readdir(path);

  // Check if this directory contains CSV files
  const hasCsvFiles = entries.some((file) => file.endsWith(".csv"));

  if (hasCsvFiles) {
    // This is an inventory directory, process it directly
    await processSingleFolder(path, verbose, outputFormat, log);
  } else {
    // This might be a parent directory, check for subdirectories
    const subdirs: string[] = [];

    for (const entry of entries) {
      const fullPath = join(path, entry);
      try {
        const entryStat = await stat(fullPath);
        if (entryStat.isDirectory()) {
          subdirs.push(fullPath);
        }
      } catch (error) {
        // Skip entries we can't access
        continue;
      }
    }

    if (subdirs.length === 0) {
      console.warn(`Warning: No CSV files or subdirectories found in ${path}`);
      return;
    }

    // Recursively process each subdirectory
    log(`Found ${subdirs.length} subdirectories to process`);
    for (const subdir of subdirs) {
      await generateDetailedDescriptions(subdir, verbose, outputFormat);
    }
  }
}
